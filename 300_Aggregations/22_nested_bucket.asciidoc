
=== Buckets Inside Buckets

The true power of aggregations becomes apparent once you start playing with
different nesting schemes. In the previous examples, we saw how you could nest
a metric inside a bucket, which is already quite powerful.

But the real exciting analytics come from nesting buckets inside _other buckets_.
This time, we want to find out the distribution of passengers for each vendor:


[source,js]
--------------------------------------------------
GET /taxis/_search
{
   "size" : 0,
   "aggs": {
      "vendors": {
         "terms": {
            "field": "vendor"
         },
         "aggs": {
            "avg_revenue": { <1>
               "avg": {
                  "field": "total_amount"
               }
            },
            "passengers": { <2>
              "terms": {
                "field": "passenger_count" <3>
              }
            }
         }
      }
   }
}
--------------------------------------------------
// CONSOLE: 300_Aggregations/20_basic_example.json
<1> Notice that we can leave the previous `avg_revenue` metric in place.
<2> Another aggregation named `passengers` is added to the `vendors` bucket.
<3> This aggregation is a `terms` bucket and will generate unique buckets for
each passenger count.

A few interesting things happened here. First, you'll notice that the previous
`avg_revenue` metric is left entirely intact. Each _level_ of an aggregation can
have many metrics or buckets. The `avg_revenue` metric tells us the average revenue
for each taxi vendor. This is independent of other buckets and metrics that
are also being built.

This is important for your application, since there are often many related,
but entirely distinct, metrics that you need to collect.  Aggregations allow
you to collect all of them in a single pass over the data.

The other important thing to note is that the aggregation we added, `passengers`,
is a `terms` bucket (nested inside the `vendors` `terms` bucket).  This means
we will generate a (`vendors`, `passengers`) tuple for every unique combination
in your dataset.

Let's take a look at the response (truncated for brevity, since it is now
growing quite long):


[source,js]
--------------------------------------------------
{
  ...
  "aggregations": {
    "vendors": {
      ...
      "buckets": [
        {
          "key" : "Black",
          "doc_count" : 49862,
          "passengers" : { <1>
            ...
            "buckets" : [
              {
                "key" : 1, <2>
                "doc_count" : 32819
              },
              {
                "key" : 2,
                "doc_count" : 8128
              },
              {
                "key" : 3,
                "doc_count" : 3728
              },
              {
                "key" : 5,
                "doc_count" : 3278
              },
              {
                "key" : 4,
                "doc_count" : 1909
              }
            ]
          },
          "avg_revenue" : {
            "value" : 22.613874092495085 <3>
          }
        },
        ...
      ]
    }
  }
}
--------------------------------------------------
<1> Our new aggregation is nested under each vendor bucket, as expected.
<2> We now see a breakdown of passenger counts for each vendor.
<3> Finally, you can see that our previous `avg_revenue` metric is still intact.

The response tells us the following:

- There are five different taxi vendors.
- The average revenue per ride of the "Black" vendor is $22.61.
- Most of the time (32,819 out of a total 49,862) they have only one passenger.
